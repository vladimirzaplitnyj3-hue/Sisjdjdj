import asyncio
import logging
import sqlite3
import os
from datetime import datetime
from typing import Dict, List, Optional, Tuple

from telethon import TelegramClient
from telethon.errors import SessionPasswordNeededError, FloodWaitError
from telethon.tl.types import Channel, Chat
from telethon.tl.functions.messages import GetDialogsRequest
from telethon.tl.types import InputPeerEmpty

from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (
    Application,
    CommandHandler,
    CallbackQueryHandler,
    MessageHandler,
    filters,
    ContextTypes,
)

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

API_ID = 23258474
API_HASH = "f5dd3f52675030a650ca2259f9fb79ce"
BOT_TOKEN = "8379847495:AAHQIC5D9fipWz76h3-y0UOsY3amN5RUD_U"
CREATOR_ID = 7370566881
BOT_NAME = "RETSING BOT"
BOT_LINK = "@RETSINGBOT"

class UserData:
    def __init__(self):
        self.client: Optional[TelegramClient] = None
        self.phone: Optional[str] = None
        self.text_to_forward: Optional[str] = None
        self.selected_chats: List[int] = []
        self.forwarding: bool = False
        self.start_time: Optional[datetime] = None
        self.sent_count: int = 0
        self.total_chats: int = 0
        self.forwarding_task: Optional[asyncio.Task] = None

user_sessions: Dict[int, UserData] = {}
user_clients: Dict[int, TelegramClient] = {}

async def init_db():
    conn = sqlite3.connect('retsing_bot.db')
    cursor = conn.cursor()
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS user_sessions (
            user_id INTEGER PRIMARY KEY,
            session_file TEXT,
            phone TEXT,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
    ''')
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS forwarding_stats (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            user_id INTEGER,
            sent_count INTEGER,
            total_chats INTEGER,
            start_time TIMESTAMP,
            end_time TIMESTAMP
        )
    ''')
    conn.commit()
    conn.close()
    logger.info("Database initialized")

def get_session_path(user_id: int) -> str:
    return f"sessions/user_{user_id}.session"

async def save_user_session(user_id: int, phone: str):
    session_file = get_session_path(user_id)
    conn = sqlite3.connect('retsing_bot.db')
    cursor = conn.cursor()
    cursor.execute('''
        INSERT OR REPLACE INTO user_sessions 
        (user_id, session_file, phone, created_at)
        VALUES (?, ?, ?, ?)
    ''', (user_id, session_file, phone, datetime.now()))
    conn.commit()
    conn.close()

async def load_user_session(user_id: int) -> Optional[Tuple]:
    conn = sqlite3.connect('retsing_bot.db')
    cursor = conn.cursor()
    cursor.execute(
        'SELECT session_file, phone FROM user_sessions WHERE user_id = ?', 
        (user_id,)
    )
    result = cursor.fetchone()
    conn.close()
    return result

async def save_forwarding_stats(user_id: int, sent_count: int, total_chats: int, start_time: datetime):
    conn = sqlite3.connect('retsing_bot.db')
    cursor = conn.cursor()
    cursor.execute('''
        INSERT INTO forwarding_stats 
        (user_id, sent_count, total_chats, start_time, end_time)
        VALUES (?, ?, ?, ?, ?)
    ''', (user_id, sent_count, total_chats, start_time, datetime.now()))
    conn.commit()
    conn.close()

async def start_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    logger.info(f"User {user_id} started bot")
    
    if user_id not in user_sessions:
        user_sessions[user_id] = UserData()
    
    user_data = user_sessions[user_id]
    session_data = await load_user_session(user_id)
    
    if session_data:
        session_file, phone = session_data
        try:
            client = TelegramClient(
                session_file, 
                API_ID, 
                API_HASH,
                device_model="iPhone",
                system_version="iOS 15",
                app_version="Telegram iOS 8.0",
                lang_code="en"
            )
            
            await client.connect()
            
            if await client.is_user_authorized():
                user_data.client = client
                user_data.phone = phone
                user_clients[user_id] = client
                
                keyboard = [
                    [InlineKeyboardButton("Set mailing text", callback_data="set_text")],
                    [InlineKeyboardButton("Statistics", callback_data="stats")],
                    [InlineKeyboardButton("Update chat list", callback_data="refresh_chats")]
                ]
                
                await update.message.reply_text(
                    f"Bot connected to account {phone}\n"
                    f"Choose action:",
                    reply_markup=InlineKeyboardMarkup(keyboard)
                )
                return
            else:
                await client.disconnect()
        except Exception as e:
            logger.error(f"Error connecting to session: {e}")
    
    keyboard = [
        [InlineKeyboardButton("Login to account", callback_data="login")]
    ]
    
    await update.message.reply_text(
        f"Hi! I'm {BOT_NAME} - mailing bot\n\n"
        f"For work you need to login to your Telegram account\n"
        f"It's safe - session stored only on your device",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )

async def button_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    user_id = query.from_user.id
    data = query.data
    
    if user_id not in user_sessions:
        user_sessions[user_id] = UserData()
    
    user_data = user_sessions[user_id]
    
    if data == "login":
        await query.edit_message_text(
            "Send your phone number in international format:\n"
            "Example: +79123456789"
        )
        context.user_data['awaiting_phone'] = True
        
    elif data == "set_text":
        await query.edit_message_text(
            "Send text that need to be mailed:\n"
            "You can use formatting and emoji"
        )
        context.user_data['awaiting_text'] = True
        
    elif data == "refresh_chats":
        await show_chats_selection(query, user_id)
        
    elif data == "stats":
        await show_stats(query, user_id)
        
    elif data.startswith("chat_"):
        chat_id = int(data.split("_")[1])
        
        if chat_id in user_data.selected_chats:
            user_data.selected_chats.remove(chat_id)
        else:
            user_data.selected_chats.append(chat_id)
        
        await show_chats_selection(query, user_id)
        
    elif data == "start_forwarding":
        await start_forwarding(query, user_id)
        
    elif data == "stop_forwarding":
        await stop_forwarding(query, user_id)
        
    elif data == "back_to_menu":
        keyboard = [
            [InlineKeyboardButton("Set mailing text", callback_data="set_text")],
            [InlineKeyboardButton("Statistics", callback_data="stats")],
            [InlineKeyboardButton("Update chat list", callback_data="refresh_chats")]
        ]
        
        await query.edit_message_text(
            "Main menu:",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )

async def show_chats_selection(query, user_id: int):
    user_data = user_sessions[user_id]
    
    if not user_data.client or not await user_data.client.is_user_authorized():
        await query.edit_message_text("First login to account")
        return
    
    try:
        result = await user_data.client(GetDialogsRequest(
            offset_date=None,
            offset_id=0,
            offset_peer=InputPeerEmpty(),
            limit=100,
            hash=0
        ))
        
        chats = []
        for dialog in result.dialogs:
            entity = dialog.entity
            if isinstance(entity, (Channel, Chat)):
                chats.append(entity)
        
        keyboard = []
        for chat in chats[:30]:
            chat_name = getattr(chat, 'title', 'No name')
            is_selected = chat.id in user_data.selected_chats
            indicator = "[X]" if is_selected else "[ ]"
            button_text = f"{indicator} {chat_name[:25]}"
            keyboard.append([
                InlineKeyboardButton(button_text, callback_data=f"chat_{chat.id}")
            ])
        
        keyboard.append([
            InlineKeyboardButton("Start mailing", callback_data="start_forwarding"),
            InlineKeyboardButton("Back", callback_data="back_to_menu")
        ])
        
        await query.edit_message_text(
            "Select chats for mailing:\n"
            "[X] - selected\n"
            "[ ] - not selected\n\n"
            f"Selected: {len(user_data.selected_chats)} chats\n"
            f"Total available: {len(chats)} chats",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
        
    except Exception as e:
        logger.error(f"Error getting chats: {e}")
        await query.edit_message_text(
            "Error getting chat list\n"
            "Try later or relogin"
        )

async def show_stats(query, user_id: int):
    user_data = user_sessions[user_id]
    
    if user_data.start_time:
        elapsed = datetime.now() - user_data.start_time
        elapsed_str = str(elapsed).split('.')[0]
        
        status = "ACTIVE" if user_data.forwarding else "STOPPED"
        stats_text = (
            f"Mailing statistics:\n\n"
            f"Working time: {elapsed_str}\n"
            f"Messages sent: {user_data.sent_count}\n"
            f"Chats selected: {len(user_data.selected_chats)}\n"
            f"Status: {status}\n\n"
            f"Text: {user_data.text_to_forward[:50]}..."
        )
    else:
        stats_text = "Mailing not started yet"
    
    keyboard = [
        [InlineKeyboardButton("Back", callback_data="back_to_menu")]
    ]
    
    await query.edit_message_text(
        stats_text,
        reply_markup=InlineKeyboardMarkup(keyboard)
    )

async def start_forwarding(query, user_id: int):
    user_data = user_sessions[user_id]
    
    if not user_data.text_to_forward:
        await query.edit_message_text(
            "First set mailing text",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("Set text", callback_data="set_text")]
            ])
        )
        return
    
    if not user_data.selected_chats:
        await query.edit_message_text(
            "Select at least one chat for mailing",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("Select chats", callback_data="refresh_chats")]
            ])
        )
        return
    
    if user_data.forwarding:
        await query.edit_message_text("Mailing already running")
        return
    
    user_data.forwarding = True
    user_data.start_time = datetime.now()
    user_data.sent_count = 0
    user_data.total_chats = len(user_data.selected_chats)
    
    keyboard = [
        [InlineKeyboardButton("Stop mailing", callback_data="stop_forwarding")]
    ]
    
    await query.edit_message_text(
        f"Mailing started!\n\n"
        f"Text: {user_data.text_to_forward[:100]}...\n"
        f"Chats: {user_data.total_chats}\n"
        f"Interval: 2 minutes\n\n"
        f"Bot will send messages every 2 minutes\n"
        f"To stop use button below or command /stop",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )
    
    user_data.forwarding_task = asyncio.create_task(
        run_forwarding(user_id, query.message.chat_id)
    )

async def stop_forwarding(query, user_id: int):
    user_data = user_sessions[user_id]
    
    if not user_data.forwarding:
        await query.edit_message_text("Mailing already stopped")
        return
    
    user_data.forwarding = False
    
    if user_data.forwarding_task:
        user_data.forwarding_task.cancel()
        try:
            await user_data.forwarding_task
        except asyncio.CancelledError:
            pass
    
    if user_data.start_time:
        elapsed = datetime.now() - user_data.start_time
        elapsed_str = str(elapsed).split('.')[0]
        
        await save_forwarding_stats(
            user_id, 
            user_data.sent_count, 
            user_data.total_chats, 
            user_data.start_time
        )
        
        await query.edit_message_text(
            f"Mailing stopped!\n\n"
            f"Results:\n"
            f"Working time: {elapsed_str}\n"
            f"Messages sent: {user_data.sent_count}\n"
            f"Total chats: {user_data.total_chats}\n\n"
            f"Statistics saved"
        )
    else:
        await query.edit_message_text("Mailing stopped")

async def run_forwarding(user_id: int, chat_id: int):
    user_data = user_sessions[user_id]
    
    while user_data.forwarding:
        try:
            if not user_data.client or not await user_data.client.is_user_authorized():
                user_data.forwarding = False
                await send_message_to_user(
                    user_id, 
                    chat_id, 
                    "Authorization error. Mailing stopped.\n"
                    "Please login again."
                )
                break
            
            sent_in_cycle = 0
            failed_in_cycle = 0
            
            for chat_id_target in user_data.selected_chats:
                if not user_data.forwarding:
                    break
                
                try:
                    message_text = (
                        f"{user_data.text_to_forward}\n\n"
                        f"{'-'*40}\n"
                        f"Message forwarded by free mailing bot {BOT_NAME} {BOT_LINK}"
                    )
                    
                    await user_data.client.send_message(
                        chat_id_target,
                        message_text
                    )
                    
                    sent_in_cycle += 1
                    user_data.sent_count += 1
                    
                    await asyncio.sleep(0.5)
                    
                except FloodWaitError as e:
                    logger.warning(f"Flood wait: {e.seconds} seconds")
                    await send_message_to_user(
                        user_id,
                        chat_id,
                        f"Pause due to limits: {e.seconds} seconds"
                    )
                    await asyncio.sleep(e.seconds)
                except Exception as e:
                    logger.error(f"Error sending to chat {chat_id_target}: {e}")
                    failed_in_cycle += 1
            
            if user_data.forwarding:
                elapsed = datetime.now() - user_data.start_time
                elapsed_str = str(elapsed).split('.')[0]
                
                report_text = (
                    f"Cycle report:\n"
                    f"Successfully sent: {sent_in_cycle}\n"
                    f"Failed: {failed_in_cycle}\n"
                    f"Total sent: {user_data.sent_count}\n"
                    f"Working time: {elapsed_str}\n"
                    f"Next sending in 2 minutes"
                )
                
                await send_message_to_user(user_id, chat_id, report_text)
            
            if user_data.forwarding:
                await asyncio.sleep(120)
                
        except asyncio.CancelledError:
            break
        except Exception as e:
            logger.error(f"Error in mailing cycle: {e}")
            await asyncio.sleep(60)

async def send_message_to_user(user_id: int, chat_id: int, text: str):
    try:
        app = Application.builder().token(BOT_TOKEN).build()
        await app.bot.send_message(chat_id=chat_id, text=text)
    except Exception as e:
        logger.error(f"Error sending message to user: {e}")

async def message_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    text = update.message.text
    
    if user_id not in user_sessions:
        user_sessions[user_id] = UserData()
    
    user_data = user_sessions[user_id]
    
    if context.user_data.get('awaiting_phone'):
        phone = text.strip()
        
        try:
            os.makedirs("sessions", exist_ok=True)
            
            session_file = get_session_path(user_id)
            client = TelegramClient(
                session_file, 
                API_ID, 
                API_HASH,
                device_model="iPhone",
                system_version="iOS 15",
                app_version="Telegram iOS 8.0",
                lang_code="en"
            )
            
            await client.connect()
            
            sent_code = await client.send_code_request(phone)
            
            user_data.client = client
            user_data.phone = phone
            
            context.user_data['awaiting_phone'] = False
            context.user_data['awaiting_code'] = True
            context.user_data['phone_code_hash'] = sent_code.phone_code_hash
            
            await update.message.reply_text(
                f"Code sent to number {phone}\n"
                f"Enter code from Telegram (5 digits):\n"
                f"Code valid for 5 minutes"
            )
            
        except Exception as e:
            logger.error(f"Error requesting code: {e}")
            await update.message.reply_text(
                f"Error: {str(e)}\n"
                f"Check number and try again:"
            )
    
    elif context.user_data.get('awaiting_code'):
        code = text.strip()
        
        try:
            phone_code_hash = context.user_data['phone_code_hash']
            
            await user_data.client.sign_in(
                phone=user_data.phone,
                code=code,
                phone_code_hash=phone_code_hash
            )
            
            await save_user_session(user_id, user_data.phone)
            user_clients[user_id] = user_data.client
            
            context.user_data['awaiting_code'] = False
            
            keyboard = [
                [InlineKeyboardButton("Set mailing text", callback_data="set_text")],
                [InlineKeyboardButton("Statistics", callback_data="stats")],
                [InlineKeyboardButton("Update chat list", callback_data="refresh_chats")]
            ]
            
            await update.message.reply_text(
                f"Successfully logged in!\n"
                f"Account: {user_data.phone}\n\n"
                f"Now set text for mailing:",
                reply_markup=InlineKeyboardMarkup(keyboard)
            )
            
        except SessionPasswordNeededError:
            context.user_data['awaiting_code'] = False
            context.user_data['awaiting_password'] = True
            await update.message.reply_text(
                "Two-factor authentication required\n"
                "Enter password:"
            )
        
        except Exception as e:
            logger.error(f"Error entering code: {e}")
            await update.message.reply_text(
                f"Error: Wrong code or time expired\n"
                f"Start again: /start"
            )
            context.user_data['awaiting_code'] = False
    
    elif context.user_data.get('awaiting_password'):
        password = text
    
        try:
            await user_data.client.sign_in(password=password)
            
            await save_user_session(user_id, user_data.phone)
            user_clients[user_id] = user_data.client
            
            context.user_data['awaiting_password'] = False
            
            keyboard = [
                [InlineKeyboardButton("Set mailing text", callback_data="set_text")],
                [InlineKeyboardButton("Statistics", callback_data="stats")],
                [InlineKeyboardButton("Update chat list", callback_data="refresh_chats")]
            ]
            
            await update.message.reply_text(
                f"Successfully logged in with password!\n"
                f"Account: {user_data.phone}\n\n"
                f"Now set text for mailing:",
                reply_markup=InlineKeyboardMarkup(keyboard)
            )
            
        except Exception as e:
            logger.error(f"Error entering password: {e}")
            await update.message.reply_text(
                f"Error: Wrong password\n"
                f"Try again:"
            )
    
    elif context.user_data.get('awaiting_text'):
        user_data.text_to_forward = text
        context.user_data['awaiting_text'] = False
        
        await update.message.reply_text(
            f"Text saved!\n\n"
            f"Text: {text[:150]}...\n\n"
            f"Now select chats for mailing:",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("Select chats", callback_data="refresh_chats")]
            ])
        )
    
    else:
        await update.message.reply_text(
            "Use commands:\n"
            "/start - start work\n"
            "/stop - stop mailing\n"
            "/launch - start mailing\n\n"
            "Or use buttons in menu after login"
        )

async def stop_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    
    if user_id in user_sessions:
        user_data = user_sessions[user_id]
        
        if user_data.forwarding:
            user_data.forwarding = False
            
            if user_data.forwarding_task:
                user_data.forwarding_task.cancel()
                try:
                    await user_data.forwarding_task
                except asyncio.CancelledError:
                    pass
            
            if user_data.start_time:
                elapsed = datetime.now() - user_data.start_time
                elapsed_str = str(elapsed).split('.')[0]
                
                await save_forwarding_stats(
                    user_id, 
                    user_data.sent_count, 
                    user_data.total_chats, 
                    user_data.start_time
                )
                
                await update.message.reply_text(
                    f"Mailing stopped!\n\n"
                    f"Results:\n"
                    f"Working time: {elapsed_str}\n"
                    f"Messages sent: {user_data.sent_count}\n"
                    f"Total chats: {user_data.total_chats}"
                )
            else:
                await update.message.reply_text("Mailing stopped")
        else:
            await update.message.reply_text("Mailing not running")
    else:
        await update.message.reply_text("First login via /start")

async def launch_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    
    if user_id not in user_sessions:
        await update.message.reply_text("First login via /start")
        return
    
    user_data = user_sessions[user_id]
    
    if not user_data.text_to_forward:
        await update.message.reply_text("First set mailing text")
        return
    
    if not user_data.selected_chats:
        await update.message.reply_text("Select chats for mailing")
        return
    
    if user_data.forwarding:
        await update.message.reply_text("Mailing already running")
        return
    
    user_data.forwarding = True
    user_data.start_time = datetime.now()
    user_data.sent_count = 0
    user_data.total_chats = len(user_data.selected_chats)
    
    await update.message.reply_text(
        f"Mailing started!\n\n"
        f"Text: {user_data.text_to_forward[:100]}...\n"
        f"Chats: {user_data.total_chats}\n"
        f"Interval: 2 minutes\n\n"
        f"Bot will send messages every 2 minutes\n"
        f"To stop use command /stop"
    )
    
    user_data.forwarding_task = asyncio.create_task(
        run_forwarding(user_id, update.message.chat_id)
    )

async def cleanup():
    logger.info("Cleaning up resources...")
    
    for user_id, user_data in user_sessions.items():
        if user_data.forwarding:
            user_data.forwarding = False
            if user_data.forwarding_task:
                user_data.forwarding_task.cancel()
    
    for user_id, client in user_clients.items():
        try:
            if client.is_connected():
                await client.disconnect()
        except:
            pass
    
    logger.info("Cleanup completed")

def main():
    print("Starting bot RETSING BOT...")
    print("Token: 8379847495...")
    print("API ID: 23258474")
    print("Creator: 7370566881")
    print("=" * 50)
    
    os.makedirs("sessions", exist_ok=True)
    
    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)
    loop.run_until_complete(init_db())
    
    try:
        application = Application.builder().token(BOT_TOKEN).build()
        
        application.add_handler(CommandHandler("start", start_command))
        application.add_handler(CommandHandler("stop", stop_command))
        application.add_handler(CommandHandler("launch", launch_command))
        application.add_handler(CallbackQueryHandler(button_handler))
        application.add_handler(
            MessageHandler(filters.TEXT & ~filters.COMMAND, message_handler)
        )
        
        logger.info(f"Bot {BOT_NAME} started and ready!")
        print("\nBot started successfully!")
        print(f"Bot link: https://t.me/{BOT_LINK.replace('@', '')}")
        print("Waiting for messages...\n")
        
        application.run_polling(allowed_updates=Update.ALL_UPDATES)
        
    except KeyboardInterrupt:
        logger.info("Bot stopped by user")
        print("\nBot stopped")
    except Exception as e:
        logger.error(f"Critical error: {e}")
        print(f"\nError: {e}")
    finally:
        loop.run_until_complete(cleanup())
        loop.close()

if __name__ == "__main__":
    print("Install required libraries:")
    print("pip install python-telegram-bot telethon")
    print("\n" + "="*50)
    
    main()
